#!/bin/sh
#
#     Shorewall Packet Filtering Firewall Control Program - V3.4
#
#     This program is under GPL [http://www.gnu.org/copyleft/gpl.htm]
#
#     (c) 1999,2000,2001,2002,2003,2004,2005,2006,2007 - Tom Eastep (teastep@shorewall.net)
#
#	This file should be placed in /sbin/shorewall.
#
#	Shorewall documentation is available at http://www.shorewall.net
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of Version 2 of the GNU General Public License
#	as published by the Free Software Foundation.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA
#
#	If an error occurs while starting or restarting the firewall, the
#	firewall is automatically stopped.
#
#	The firewall uses configuration files in /etc/shorewall/ - skeleton
#	files is included with the firewall.
#
#	Commands are:
#
#          shorewall add <iface>[:<host>] zone     Adds a host or subnet to a zone
#          shorewall delete <iface>[:<host>] zone  Deletes a host or subnet from a zone
#          shorewall dump                          Dumps all Shorewall-related information
#                                                  for problem analysis
#	   shorewall start 			   Starts the firewall
#	   shorewall restart			   Restarts the firewall
#	   shorewall stop			   Stops the firewall
#	   shorewall status			   Displays firewall status
#	   shorewall reset			   Resets iptables packet and
#						   byte counts
#	   shorewall clear			   Open the floodgates by
#						   removing all iptables rules
#						   and setting the three permanent
#						   chain policies to ACCEPT
#	   shorewall refresh			   Rebuild the common chain to
#						   compensate for a change of
#						   broadcast address on any "detect"
#						   interface.
#	   shorewall [re]load [ <directory> ] <system>
#						   Compile a script and install it on a
#						   remote Shorewall Lite system.
#	   shorewall show <chain> [ <chain> ... ]  Display the rules in each <chain> listed
#          shorewall show actions                  Displays the available actions
#	   shorewall show log			   Print the last 20 log messages
#	   shorewall show connections		   Show the kernel's connection
#						   tracking table
#	   shorewall show nat			   Display the rules in the nat table
#	   shorewall show {mangle|tos}		   Display the rules in the mangle table
#	   shorewall show tc			   Display traffic control info
#	   shorewall show classifiers		   Display classifiers
#          shorewall show capabilities             Display iptables/kernel capabilities
#	   shorewall version			   Display the installed version id
#	   shorewall check [ -e ] [ <directory> ]  Dry-run compilation.
#	   shorewall try <directory> [ <timeout> ] Try a new configuration and if
#						   it doesn't work, revert to the
#						   standard one. If a timeout is supplied
#						   the command reverts back to the
#						   standard configuration after that many
#						   seconds have elapsed after successfully
#						   starting the new configuration.
#	   shorewall logwatch [ refresh-interval ] Monitor the local log for Shorewall
#						   messages.
#	   shorewall drop <address> ...		   Temporarily drop all packets from the
#						   listed address(es)
#	   shorewall reject <address> ...	   Temporarily reject all packets from the
#						   listed address(es)
#	   shorewall allow <address> ...	   Reenable address(es) previously
#						   disabled with "drop" or "reject"
#	   shorewall save [ <file> ]		   Save the list of "rejected" and
#						   "dropped" addresses so that it will
#						   be automatically reinstated the
#						   next time that Shorewall starts.
#                                                  Save the current state so that 'shorewall
#                                                  restore' can be used.
#
#          shorewall forget [ <file> ]             Discard the data saved by 'shorewall save'
#
#          shorewall restore [ <file> ]            Restore the state of the firewall from
#                                                  previously saved information.
#
#          shorewall ipaddr { <address>/<cidr> | <address> <netmask> }
#
#                                                  Displays information about the network
#                                                  defined by the argument[s]
#
#          shorewall iprange <address>-<address>   Decomposes a range of IP addresses into
#                                                  a list of network/host addresses.
#
#          shorewall ipdecimal { <address> | <integer> }
#
#                                                  Displays the decimal equivalent of an IP
#                                                  address and vice versa.
#
#          shorewall safe-start [ <directory> ]    Starts the firewall and promtp for a c
#                                                  confirmation to accept or reject the new
#                                                  configuration
#
#          shorewall safe-restart [ <directory> ]  Restarts the firewall and prompt for a
#                                                  confirmation to accept or reject the new
#                                                  configuration
#
#          shorewall compile [ -e ] [ <directory> ] <filename>
#                                                  Compile a firewall program file.

#
# Set the configuration variables from shorewall.conf
#
get_config() {

    ensure_config_path

    if [ "$1" = Yes ]; then
	params=$(find_file params)

	if [ -f $params ]; then
	    . $params
	fi
    fi

    config=$(find_file shorewall.conf)
    
    if [ -f $config ]; then
	if [ -r $config ]; then
	    . $config
	else
	    echo "Cannot read $config! (Hint: Are you root?)" >&2
	    exit 1
	fi
    else
	echo "$config does not exist!" >&2
	exit 2
    fi

    ensure_config_path
    
    if [ -z "$EXPORT" -a "$(id -u)" = 0 ]; then
	#
	# This block is avoided for compile for export and when the user isn't root
	#
	export CONFIG_PATH

	[ -z "$LOGFILE" ] && LOGFILE=/var/log/messages

	if [ -n "$(syslog_circular_buffer)" ]; then
	    LOGREAD="logread"
	elif [ -f $LOGFILE ]; then
	    LOGREAD="cat $LOGFILE"
	else
	    echo "LOGFILE ($LOGFILE) does not exist!" >&2
	    exit 2
	fi

	if [ -n "$IPTABLES" ]; then
	    if [ ! -x "$IPTABLES" ]; then
		echo "   ERROR: The program specified in IPTABLES does not exist or is not executable" >&2
		exit 2
	    fi
	else
	    IPTABLES=$(mywhich iptables 2> /dev/null)
	    if [ -z "$IPTABLES" ] ; then
		echo "   ERROR: Can't find iptables executable" >&2
		exit 2
	    fi
	fi

	export IPTABLES

        #
        # See if we have a real version of "tail" -- use separate redirection so
        # that ash (aka /bin/sh on LRP) doesn't crap
        #
	if ( tail -n5 /dev/null > /dev/null 2> /dev/null ) ; then
	    realtail="Yes"
	else
	    realtail=""
	fi
	#
	# Compile by non-root needs no restore file
	#
	[ -n "$RESTOREFILE" ] || RESTOREFILE=restore

	validate_restorefile RESTOREFILE

	export RESTOREFILE

	case $STARTUP_ENABLED in
	    No|no|NO)
                echo "   WARNING: Shorewall startup is disabled. To enable startup, set STARTUP_ENABLED=Yes in ${CONFDIR}/shorewall.conf" >&2
		STARTUP_ENABLED=
		;;
	    Yes|yes|YES)
	        ;;
	    *)
		if [ -n "$STARTUP_ENABLED" ]; then
		    echo "   ERROR: Invalid Value for STARTUP_ENABLE: $STARTUP_ENABLED" >&2
		    exit 2
		fi
		;;
	esac

	case ${TC_ENABLED:=Internal} in
	    No|NO|no)
	        TC_ENABLED=
		;;
	esac

	[ -n "LOGFORMAT" ] && LOGFORMAT="${LOGFORMAT%%%*}"

	[ -n "$LOGFORMAT" ] || LOGFORMAT="Shorewall:"

	export LOGFORMAT

    fi

    if [ -n "$SHOREWALL_SHELL" ]; then
	if [ ! -x "$SHOREWALL_SHELL" ]; then
	    echo "   ERROR: The program specified in SHOREWALL_SHELL does not exist or is not executable" >&2
	    exit 2
	fi
    fi

    [ -n "${VERBOSITY:=2}" ]

    VERBOSE=$(($VERBOSE_OFFSET + $VERBOSITY))

    export VERBOSE

    [ -n "${HOSTNAME:=$(hostname)}" ]

    [ -n "$RSH_COMMAND" ] || RSH_COMMAND='ssh ${root}@${system} ${command}'
    [ -n "$RCP_COMMAND" ] || RCP_COMMAND='scp ${files} ${root}@${system}:${destination}' 

}

#
# Run the appropriate compiler
#
compiler() {
    local sc=${SHELLSHAREDIR}/compiler
    local pc=${PERLSHAREDIR}/compiler.pl

    startup_error() {
	echo "   ERROR: $@" >&2
	exit 1
    }
    
    local command=$1

    shift
    
    if [ $(id -u) -ne 0 ]; then
	if [ -z "$SHOREWALL_DIR" -o "$SHOREWALL_DIR" = /etc/shorewall ]; then
	    startup_error "Ordinary users may not compile the /etc/shorewall configuration"
	fi
    fi
    #
    # We've now set SHOREWALL_DIR so recalculate CONFIG_PATH
    #
    ensure_config_path
    #
    # Run the appropriate params file
    #
    [ -d /usr/share/shorewall-perl ] && set -a; 
    
    run_user_exit params

    set +a

    if [ -n "$SHOREWALL_COMPILER" ]; then
	compiler="$SHOREWALL_COMPILER"
    elif [ -x $sc ]; then
	compiler=shell
    elif [ -x $pc ]; then
	compiler=perl
    else
	fatal_error "No shorewall compiler installed"
    fi

    if [ -z "$compiler" ]; then
        #
        # Both compilers installed. Read the appropriate shorewall.conf to learn the setting of SHOREWALL_COMPILER
        #
	config=$(find_file shorewall.conf)

	if [ -f $config ]; then
	    if [ -r $config ]; then
		progress_message "Processing $config..."
		. $config
	    else
		startup_error "Cannot read $config (Hint: Are you root?)"
	    fi
	else
	    startup_error "$config does not exist!"
	fi
        #
        # And initiate the appropriate compiler
        #
	[ -n "$SHOREWALL_COMPILER" ] && compiler="$SHOREWALL_COMPILER"
    fi

    [ $command = exec ] || command=
    
    case "$compiler" in
	perl)
	    [ -x $pc ] || startup_error "SHOREWALL_COMPILER=perl requires the shorewall-perl package which is not installed"
	    debugflags="-w"
	    [ -n "$DEBUG" ]   && debugflags='-wd'
	    [ -n "$PROFILE" ] && debugflags='-wd:DProf'

	    shift # Perl compiler only takes the output file as a argument

	    $command perl $debugflags $pc $@
	    ;;
	shell)
	    [ -x $sc ] || startup_error "SHOREWALL_COMPILER=shell requires the shorewall-shell package which is not installed"
	    $command $SHOREWALL_SHELL $sc $@
	    ;;
	*)
	    startup_error "Invalid value ($SHOREWALL_COMPILER) for SHOREWALL_COMPILER"
	    ;;
    esac
}    

#
# Start Command Executor
#
start_command() {
    local finished=0

    do_it() {
	local rc=0

	[ -n "$nolock" ] || mutex_on

	progress_message3 "Compiling..."

	if compiler run $debugging $nolock compile ${VARDIR}/.start; then
	    ${VARDIR}/.start $debugging start
	    rc=$?
	else
	    rc=$?
	    logger -p kern.err "ERROR:Shorewall start failed"
	fi

	[ -n "$nolock" ] || mutex_off
	exit $rc
    }

    if shorewall_is_started; then
	error_message "Shorewall is already running"
	exit 0
    fi

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			f*)
			    FAST=Yes
			    option=${option#f}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" -o -n "$FAST" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    export SHOREWALL_DIR
	    ;;
	*)
	    usage 1
	    ;;
    esac

    export NOROUTES

    if [ -n "$FAST" ]; then
	if qt mywhich make; then
	    #
	    # RESTOREFILE is exported by get_config()
	    #
	    make -qf ${CONFDIR}/Makefile || FAST=
	fi

	if [ -n "$FAST" ]; then

	    RESTOREPATH=${VARDIR}/$RESTOREFILE

	    if [ -x $RESTOREPATH ]; then
		if [ -x ${RESTOREPATH}-ipsets ]; then
		    echo Restoring Ipsets...
		    #
		    # We must purge iptables to be sure that there are no
		    # references to ipsets
		    #
		    iptables -F
		    iptables -X
		    $SHOREWALL_SHELL ${RESTOREPATH}-ipsets
		fi

		echo Restoring Shorewall...
		$SHOREWALL_SHELL $RESTOREPATH restore
		date > ${VARDIR}/restarted
		progress_message3 Shorewall restored from $RESTOREPATH
	    else
		do_it
	    fi
	else
	    do_it
	fi
    else
	do_it
    fi
}

#
# Compile Command Executor
#
compile_command() {
    local finished=0

    while [ $finished -eq 0 ]; do
	[ $# -eq 0 ] && usage 1
	option=$1
	case $option in
	    -*)
		shift
		option=${option#-}

		[ -z "$option" ] && usage 1

		while [ -n "$option" ]; do
		    case $option in
			e*)
			    EXPORT=Yes
			    option=${option#e}
			    ;;
			p*)
			    PROFILE=Yes
			    option=${option#p}
			    ;;
			C)
			    [ $# -gt 0 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$1
			    option=
			    shift
			    ;;
			d*)
			    DEBUG=Yes;
			    option=${option#d}
			    ;;
			-)
			    finished=1
			    option=
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		;;
	    *)
		finished=1
		;;
	esac
    done

    file=

    case $# in
	1)
	    file=$1
	    [ -d $file ] && echo "   ERROR: $file is a directory" >&2 && exit 2;
	    ;;
	2)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    export SHOREWALL_DIR
	    file=$2
	    ;;
	*)
	    usage 1
	    ;;
    esac

    export EXPORT

    progress_message3 "Compiling..."

    compiler exec $debugging compile $file
}

#
# Check Command Executor
#
check_command() {
    local finished=0

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			e*)
			    EXPORT=Yes
			    option=${option#e}
			    ;;
			p*)
			    PROFILE=Yes
			    option=${option#p}
			    ;;
			d*)
			    DEBUG=Yes;
			    option=${option#d}
			    ;;
			C)
			    [ $# -gt 0 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    export SHOREWALL_DIR
	    ;;
	*)
	    usage 1
	    ;;
    esac

    export EXPORT

    progress_message3 "Checking..."

    compiler exec $debugging $nolock check
}

#
# Restart Command Executor
#
restart_command() {
    local finished=0 rc=0

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			n*)
			    NOROUTES=Yes
			    option=${option#n}
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    export SHOREWALL_DIR
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    export NOROUTES

    [ -n "$nolock" ] || mutex_on

    progress_message3 "Compiling..."

    if compiler run $debugging $nolock compile ${VARDIR}/.restart; then
	$SHOREWALL_SHELL ${VARDIR}/.restart $debugging restart
	rc=$?
    else
	rc=$?
	logger -p kern.err "ERROR:Shorewall restart failed"
    fi

    [ -n "$nolock" ] || mutex_off

    return $rc
}

#
# Refresh Command Executor
#
refresh_command() {
    local finished=0

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	*)
	    usage 1
	    ;;
    esac

    shorewall_is_started || fatal_error "Shorewall is not running"

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    export NOROUTES

    [ -n "$nolock" ] || mutex_on

    progress_message3 "Compiling..."

    if compiler run $debugging $nolock compile ${VARDIR}/.refresh; then
	$SHOREWALL_SHELL ${VARDIR}/.refresh $debugging refresh
    fi

    rc=$?

    [ -n "$nolock" ] || mutex_off

    return $rc
}

#
# Safe-start/safe-restart Command Executor
#
safe_commands() {
    local finished=0

    # test is the shell supports timed read
    read -t 0 junk 2> /dev/null
    if [ $? -eq 2 -a ! -x /bin/bash ];then
	echo "Your shell does not support a feature required to execute this command".
	exit 2
    fi

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			n*)
			    NOROUTES=Yes
			    option=${option#n}
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    export SHOREWALL_DIR
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    mutex_on

    if shorewall_is_started; then
	running=Yes
    else
	running=
    fi

    if [ "$COMMAND" = "safe-start" -a  -n "$running" ]; then
	# the command is safe-start but the firewall is already running
	error_message "Shorewall is already started"
	mutex_off
	exit 0
    fi

    if [ "$COMMAND" = "safe-start" -o -z "$running" ]; then
	# the command is safe-start or shorewall is not started yet
	command="start"
    else
	# the command is safe-restart and the firewall is already running
	command="restart"
    fi

    progress_message3 "Compiling..."

    if ! compiler run $debugging nolock compile ${VARDIR}/.$command; then
	status=$?
	mutex_off
	exit $status
    fi

    case $command in
	start)
	    export RESTOREFILE=NONE
	    progress_message3 "Starting..."
	    ;;
	restart)
	    export RESTOREFILE=.safe
	    RESTOREPATH=${VARDIR}/.safe
	    save_config
	    progress_message3 "Restarting..."
	    ;;
    esac

    if ${VARDIR}/.$command $command; then

	echo -n "Do you want to accept the new firewall configuration? [y/n] "

	if read_yesno_with_timeout; then
	    echo "New configuration has been accepted"
	else
	    if [ "$command" = "restart" ]; then
		${VARDIR}/.safe restore
	    else
		${VARDIR}/.$command clear
	    fi
	    
	    mutex_off
	    echo "New configuration has been rejected and the old one restored"
	    exit 2
	fi

    fi

    mutex_off
}

#
# 'try' Command Executor
#
try_command() {
    local finished=0 timeout=

    handle_directory() {
	[ -n "$SHOREWALL_DIR" ] && usage 2

	if [ ! -d $1 ]; then
	    if [ -e $1 ]; then
		echo "$1 is not a directory" >&2 && exit 2
	    else
		echo "Directory $1 does not exist" >&2 && exit 2
	    fi
	fi
	
	SHOREWALL_DIR=$(resolve_file $1)
	export SHOREWALL_DIR
    }

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			n*)
			    NOROUTES=Yes
			    option=${option#n}
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    usage 1
	    ;;
	1)
	    handle_directory $1
	    ;;
	2)
	    handle_directory $1
	    timeout=$2
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    mutex_on

    if shorewall_is_started; then
	running=Yes
    else
	running=
    fi

    if [ -z "$running" ]; then
	# shorewall is not started yet
	command="start"
    else
	# the firewall is already running
	command="restart"
    fi

    progress_message3 "Compiling..."

    if ! compiler run $debugging nolock compile ${VARDIR}/.$command; then
	status=$?
	mutex_off
	exit $status
    fi

    case $command in
	start)
	    export RESTOREFILE=NONE
	    progress_message3 "Starting..."
	    ;;
	restart)
	    export RESTOREFILE=.try
	    RESTOREPATH=${VARDIR}/.try
	    save_config
	    progress_message3 "Restarting..."
	    ;;
    esac

    if ${VARDIR}/.$command $command && [ -n "$timeout" ]; then
	sleep $timeout
	    
	if [ "$command" = "restart" ]; then
	    ${VARDIR}/.try restore
	else
	    ${VARDIR}/.$command clear
	fi	    
    fi

    mutex_off

    return 0
}

rsh_command() {
    command="$*"

    eval $RSH_COMMAND
}

rcp_command() {
    files="$1"
    destination=$2
    
    eval $SCP_COMMAND
}

#
# [Re]load command executor
#
reload_command() # $* = original arguments less the command.
{
    local verbose=$(make_verbose) file= capabilities= finished=0 saveit= result directory system getcaps= root=root

    [ -n "$LITEDIR" ] || fatal_error "ERROR: LITEDIR not defined in ${SHAREDIR}/configpath"

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			s*)
			    saveit=Yes
			    option=${option#s}
			    ;;
			c*)
			    getcaps=Yes
			    option=${option#c}
			    ;;
			r)
			    [ $# -gt 1 ] || fatal_error "Missing Root User name"
			    root=$2
			    option=
			    shift
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	1)
	    directory="."
	    system=$1
	    ;;
	2)
	    directory=$1
	    system=$2
	    ;;
	*)
	    usage 1
	    ;;
    esac

    litedir=$(rsh_command /sbin/shorewall-lite show config 2> /dev/null | grep ^LITEDIR | sed 's/LITEDIR is //')

    [ -n "$litedir" ] && LITEDIR=$litedir

    if [ -z "$getcaps" ]; then
	SHOREWALL_DIR=$(resolve_file $directory)
	ensure_config_path
	capabilities=$(find_file capabilities)
	[ -f $capabilities ] || getcaps=Yes
    fi

    if [ -n "$getcaps" ]; then
	if [ -f $directory/shorewall.conf ]; then
	    . $directory/shorewall.conf
	    ensure_config_path
	fi

	progress_message "Getting Capabilities on system $system..."
	if ! rsh_command "MODULESDIR=$MODULESDIR MODULE_SUFFIX=\"$MODULE_SUFFIX\" IPTABLES=$IPTABLES /usr/share/shorewall-lite/shorecap" > $directory/capabilities; then
	    fatal_error "ERROR: Capturing capabilities on system $system failed"
	fi
    fi

    file=$(resolve_file $directory/firewall)

    if shorewall $debugging $verbose compile -e $directory $directory/firewall && \
	progress_message "Copying $file and ${file}.conf to ${system}:${LITEDIR}..." && \
	rcp_command "$directory/firewall $directory/firewall.conf" ${LITEDIR}
    then
	echo "Copy complete"
	if [ $COMMAND = reload ]; then
	    rsh_command "/sbin/shorewall-lite $debugging $verbose restart" && \
	    progress_message3 "System $system reloaded" || saveit=
	else
	    rsh_command "/sbin/shorewall-lite $debugging $verbose restart" && \
	    progress_message3 "System $system reloaded" || saveit=
	fi

	if [ -n "$saveit" ]; then
	    rsh_command "/sbin/shorewall-lite $debugging $verbose save" && \
	    progress_message3 "Configuration on system $system saved"
	fi
    fi
}

#
# Export command executor
#
export_command() # $* = original arguments less the command.
{
    local verbose=$(make_verbose) file= finished=0 directory target

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			C)
			    [ $# -gt 1 ] || fatal_error "-C must be followed by a compiler name"
			    SHOREWALL_COMPILER=$2
			    option=
			    shift
			    ;;
			*)
			    fatal_error "Unrecognized option \"$option\""
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	1)
	    directory="."
	    target=$1
	    ;;
	2)
	    directory=$1
	    target=$2
	    ;;
	*)
	    fatal_error "ERROR: Invalid command syntax (\"man shorewall\" for help)"
	    ;;
    esac

    case $target in
	*:*)
	    ;;
	*)
	    target=$target:
	    ;;
    esac

    file=$(resolve_file $directory/firewall)

    if shorewall $debugging $verbose compile -e $directory $directory/firewall && \
	echo "Copying $file and ${file}.conf to ${target#*@}..." && \
	scp $directory/firewall $directory/firewall.conf $target
    then
	progress_message3 "Copy complete"
    fi
}

#
# Give Usage Information
#
usage() # $1 = exit status
{
    echo "Usage: $(basename $0) [debug|trace] [nolock] [ -q ] [ -v ] [ -t ] <command>"
    echo "where <command> is one of:"
    echo "   add <interface>[:<host-list>] ... <zone>"
    echo "   allow <address> ..."
    echo "   check [ -e ] [ -C {shell|perl} ] [ <directory> ]"
    echo "   clear"
    echo "   compile [ -e ] [ -C {shell|perl} ] [ <directory name> ] <path name>"
    echo "   delete <interface>[:<host-list>] ... <zone>"
    echo "   drop <address> ..."
    echo "   dump [ -x ]"
    echo "   export [ -C {shell|perl} ] [ <directory1> ] [<user>@]<system>[:<directory2>]"
    echo "   forget [ <file name> ]"
    echo "   help"
    echo "   hits"
    echo "   ipcalc { <address>/<vlsm> | <address> <netmask> }"
    echo "   ipdecimal { <address> | <integer> }"
    echo "   iprange <address>-<address>"
    echo "   load [ -s ] [ -c ] [ -r <root user> ] [ -C {shell|perl} ] [ <directory> ] <system>"
    echo "   logdrop <address> ..."
    echo "   logreject <address> ..."
    echo "   logwatch [<refresh interval>]"
    echo "   refresh [ -C {shell|perl} ]"
    echo "   reject <address> ..."
    echo "   reload [ -s ] [ -c ] [ -r <root user> ] [ -C {shell|perl} ] [ <directory> ] <system>"
    echo "   reset"
    echo "   restart [ -n ] [ -C {shell|perl} ] [ <directory> ]"
    echo "   restore [ -n ] [ <file name> ]"
    echo "   save [ <file name> ]"
    echo "   show [ -x ] [ -m ] [-f] [ -t {filter|mangle|nat} ] [<chain> [ <chain> ... ]|actions|capabilities|classifiers|config|connections|ip|log|macros|mangle|nat|routing|tc|zones]"
    echo "   start [ -f ] [ -n ] [ -C {shell|perl} ] [ <directory> ]"
    echo "   stop"
    echo "   status"
    echo "   try [ -C {shell|perl} ] <directory> [ <timeout> ]"
    echo "   version"
    echo "   safe-start [ -C {shell|perl} ] [ <directory> ]"
    echo "   safe-restart [ -C {shell|perl} ] [ <directory> ]"
    echo
    exit $1
}

#
# Execution begins here
#
debugging=

if [ $# -gt 0 ] && [ "x$1" = "xdebug" -o "x$1" = "xtrace" ]; then
    debugging=debug
    shift
fi

nolock=

if [ $# -gt 0 ] && [ "$1" = "nolock" ]; then
    nolock=nolock
    shift
fi

SHOREWALL_DIR=
IPT_OPTIONS="-nv"
FAST=
VERBOSE_OFFSET=0
NOROUTES=
EXPORT=
export TIMESTAMP=
noroutes=

finished=0

while [ $finished -eq 0 ]; do
    [ $# -eq 0 ] && usage 1
    option=$1
    case $option in
	-)
	    finished=1
	    ;;
	-*)
	    option=${option#-}

	    while [ -n "$option" ]; do
		case $option in
		    c)
			[ $# -eq 1 ] && usage 1

			if [ ! -d $2 ]; then
			    if [ -e $2 ]; then
				echo "$2 is not a directory" >&2 && exit 2
			    else
				echo "Directory $2 does not exist" >&2 && exit 2
			    fi
			fi

			SHOREWALL_DIR=$(resolve_file $2)
			option=
			shift
			;;
		    e*)
			EXPORT=Yes
			option=${option#e}
			;;
		    x*)
			IPT_OPTIONS="-xnv"
			option=${option#x}
			;;
		    q*)
			VERBOSE_OFFSET=$(($VERBOSE_OFFSET - 1 ))
			option=${option#q}
			;;
		    f*)
			FAST=Yes
			option=${option#f}
			;;
		    v*)
			VERBOSE_OFFSET=$(($VERBOSE_OFFSET + 1 ))
			option=${option#v}
			;;
		    n*)
			NOROUTES=Yes
			option=${option#n}
			;;
		    t*)
			TIMESTAMP=Yes
			option=${option#t}
			;;
		    -)
			finished=1
			option=
			;;
		    *)
			usage 1
			;;
		esac
	    done
	    shift
	    ;;
	*)
	    finished=1
            ;;
    esac
done

if [ $# -eq 0 ]; then
    usage 1
fi

[ -n "$SHOREWALL_DIR" ] && export SHOREWALL_DIR
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin
MUTEX_TIMEOUT=

SHAREDIR=/usr/share/shorewall
VARDIR=/var/lib/shorewall
CONFDIR=/etc/shorewall
export PRODUCT="Shorewall"

FIREWALL=$SHAREDIR/firewall
LIBRARIES="$SHAREDIR/lib.base $SHAREDIR/lib.cli"
VERSION_FILE=$SHAREDIR/version
HELP=$SHAREDIR/help

for library in $LIBRARIES; do
    if [ -f $library ]; then
	. $library
    else
	echo "$library does not exist!" >&2
	exit 2
    fi
done

if [ ! -f $FIREWALL ]; then
    echo "   ERROR: Shorewall is not properly installed" >&2
    if [ -L $FIREWALL ]; then
	echo "	     $FIREWALL is a symbolic link to a" >&2
	echo "	     non-existant file" >&2
    else
	echo "	     The file $FIREWALL does not exist" >&2
    fi

    exit 2
fi

if [ -f $VERSION_FILE ]; then
    version=$(cat $VERSION_FILE)
else
    echo "   ERROR: Shorewall is not properly installed" >&2
    echo "	 The file $VERSION_FILE does not exist"  >&2
    exit 1
fi

banner="Shorewall-$version Status at $HOSTNAME -"

case $(echo -e) in
    -e*)
	RING_BELL="echo \a"
	;;
    *)
	RING_BELL="echo -e \a"
	;;
esac

case $(echo -n "Testing") in
    -n*)
	ECHO_N=
	;;
    *)
	ECHO_N=-n
	;;
esac

COMMAND=$1

case "$COMMAND" in
    start)
	get_config
	shift
	start_command $@
	;;
    stop|reset|clear)
	[ $# -ne 1 ] && usage 1
	get_config
	export NOROUTES
	exec $SHOREWALL_SHELL $FIREWALL $debugging $nolock $COMMAND
	;;
    compile)
	get_config
	shift
	compile_command $@
	;;
    restart)
	get_config
	shift
	restart_command $@
	;;
    refresh)
	get_config
	shift
	refresh_command $@
	;;
    check)
	get_config
	shift
	check_command $@
	;;
    add|delete)
	[ $# -lt 3 ] && usage 1
	get_config
	exec $SHOREWALL_SHELL $FIREWALL $debugging $nolock $@
	;;
    show|list)
	get_config Yes
    	shift
    	show_command $@
	;;
    load|reload)
	get_config
	shift
	reload_command $@
	;;
    export)
	get_config
	shift
	export_command $@
	;;
    status)
	[ $# -eq 1 ] || usage 1
	get_config
	echo "Shorewall-$version Status at $HOSTNAME - $(date)"
	echo
	if shorewall_is_started ; then
	    echo "Shorewall is running"
	    status=0
	else
	    echo "Shorewall is stopped"
	    status=4
	fi

	if [ -f ${VARDIR}/state ]; then
	    state="$(cat ${VARDIR}/state)"
	    case $state in
		Stopped*|Clear*)
		    status=3
		    ;;
	    esac
	else
	    state=Unknown
	fi
	echo "State:$state"
	echo
	exit $status
	;;
    dump)
	get_config Yes
    	shift
    	dump_command $@
	;;
    hits)
	get_config Yes
	[ -n "$debugging" ] && set -x
	[ $# -eq 1 ] || usage 1
	hits_command
	;;
    version)
	echo $version
	;;
    try)
	get_config
	shift
	try_command $@
	;;
    logwatch)
	get_config Yes
	banner="Shorewall-$version Logwatch at $HOSTNAME -"
	logwatch_command $@
	;;
    drop)
	get_config
	[ -n "$debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall_is_started ; then
	    mutex_on
	    block DROP Dropped $*
	    mutex_off
	else
	    fatal_error "Shorewall is not started"
	fi
	;;
    logdrop)
	get_config
	[ -n "$debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall_is_started ; then
	    mutex_on
	    block logdrop Dropped $*
	    mutex_off
	else
	    fatal_error "Shorewall is not started"
	fi
	;;
    reject|logreject)
	get_config
	[ -n "$debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall_is_started ; then
	    mutex_on
	    block $COMMAND Rejected $*
	    mutex_off
	else
	    fatal_error "Shorewall is not started"
	fi
	;;
    allow)
	get_config
	allow_command $@
	;;
    save)
	get_config
	[ -n "$debugging" ] && set -x

	case $# in
	1)
	    ;;
	2)
	    RESTOREFILE="$2"
	    validate_restorefile '<restore file>'
	    ;;
	*)
	    usage 1
	    ;;
	esac

	RESTOREPATH=${VARDIR}/$RESTOREFILE
	mutex_off

	[ "$nolock" ] || mutex_on

	save_config

	[ "$nolock" ] || mutex_off
	;;
    forget)
	get_config
	case $# in
	1)
	    ;;
	2)
	    RESTOREFILE="$2"
	    validate_restorefile '<restore file>'
	    ;;
	*)
	    usage 1
	    ;;
	esac


	RESTOREPATH=${VARDIR}/$RESTOREFILE

	if [ -x $RESTOREPATH ]; then

	    if [ -x ${RESTOREPATH}-ipsets ]; then
		rm -f ${RESTOREPATH}-ipsets
		echo "    ${RESTOREPATH}-ipsets removed"
	    fi

	    rm -f $RESTOREPATH
	    rm -f ${RESTOREPATH}-iptables
	    echo "    $RESTOREPATH removed"
	elif [ -f $RESTOREPATH ]; then
	    echo "   $RESTOREPATH exists and is not a saved Shorewall configuration"
	fi
	rm -f ${VARDIR}/save
	;;
    ipcalc)
    	[ -n "$debugging" ] && set -x
	if [ $# -eq 2 ]; then
	    address=${2%/*}
	    vlsm=${2#*/}
	elif [ $# -eq 3 ]; then
	    address=$2
	    vlsm=$(ip_vlsm $3)
	else
	    usage 1
	fi

	valid_address $address || fatal_error "Invalid IP address: $address"
	[ -z "$vlsm" ] && exit 2
	[ "x$address" = "x$vlsm" ] && usage 2
	[ $vlsm -gt 32 ] && echo "Invalid VLSM: /$vlsm" >&2 && exit 2

	address=$address/$vlsm

	                                   echo "   CIDR=$address"
	temp=$(ip_netmask $address);       echo "   NETMASK=$(encodeaddr $temp)"
	temp=$(ip_network $address);       echo "   NETWORK=$temp"
	temp=$(broadcastaddress $address); echo "   BROADCAST=$temp"
	;;

    iprange)
	[ -n "$debugging" ] && set -x
	case $2 in
	    *.*.*.*-*.*.*.*)
		for address in ${2%-*} ${2#*-}; do
		    valid_address $address || fatal_error "Invalid IP address: $address"
		done

		ip_range $2
		;;
	    *)
		usage 1
		;;
	esac
	;;
    ipdecimal)
	[ -n "$debugging" ] && set -x
	case $2 in
	    *.*.*.*)
		valid_address $2 || fatal_error "Invalid IP address: $2"
		echo "   $(decodeaddr $2)"
		;;
	    *)
		echo "   $(encodeaddr $2)"
		;;
	esac
	;;
    restore)
	get_config
	shift
	restore_command $@
        ;;
    call)
	get_config
	[ -n "$debugging" ] && set -x
	#
	# Undocumented way to call functions in ${SHAREDIR}/functions directly
	#
	shift
	$@
	;;
    help)
	shift
	usage
	;;
    safe-restart|safe-start)
	get_config
	shift
	safe_commands $@
	;;
    *)
	usage 1
	;;

esac
