#!/bin/sh
#
#     Shorewall Packet Filtering Firewall Control Program - V4.2
#
#     This program is under GPL [http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt]
#
#     (c) 1999,2000,2001,2002,2003,2004,2005,2006,2007,2008 - Tom Eastep (teastep@shorewall.net)
#
#	This file should be placed in /sbin/shorewall6.
#
#	Shorewall documentation is available at http://www.shorewall.net
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of Version 2 of the GNU General Public License
#	as published by the Free Software Foundation.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#       For a list of supported commands, type 'shorewall6 help'
#
################################################################################################
#
# Set the configuration variables from shorewall6.conf
#
#     $1 = Yes: read the params file
#     $2 = Yes: check for STARTUP_ENABLED
#     $3 = Yes: Check for LOGFILE
#     
#
get_config() {

    ensure_config_path

    if [ "$1" = Yes ]; then
	params=$(find_file params)

	if [ -f $params ]; then
	    . $params
	fi
    fi

    config=$(find_file shorewall6.conf)
    
    if [ -f $config ]; then
	if [ -r $config ]; then
	    . $config
	else
	    echo "Cannot read $config! (Hint: Are you root?)" >&2
	    exit 1
	fi
    else
	echo "$config does not exist!" >&2
	exit 2
    fi

    ensure_config_path
    
    if [ -z "$g_export" -a "$(id -u)" = 0 ]; then
	#
	# This block is avoided for compile for export and when the user isn't root
	#
	if [ "$3" = Yes ]; then
	    if [ -n "$LOGFILE" ]; then
		if [ -n "$(syslog_circular_buffer)" ]; then
		    g_logread="logread | tac"
		elif [ -r $LOGFILE ]; then
		    g_logread="tac $LOGFILE"
		else
		    echo "LOGFILE ($LOGFILE) does not exist!" >&2
		    exit 2
		fi
	    fi
	fi

	if [ -n "$IP6TABLES" ]; then
	    if [ ! -x "$IP6TABLES" ]; then
		echo "   ERROR: The program specified in IP6TABLES does not exist or is not executable" >&2
		exit 2
	    fi
	else
	    IP6TABLES=$(mywhich ip6tables 2> /dev/null)
	    if [ -z "$IP6TABLES" ] ; then
		echo "   ERROR: Can't find ip6tables executable" >&2
		exit 2
	    fi
	fi

	#
	# Compile by non-root needs no restore file
	#
	[ -n "$RESTOREFILE" ] || RESTOREFILE=restore

	validate_restorefile RESTOREFILE

	if [ "$2" = Yes ]; then
	    case $STARTUP_ENABLED in
		No|no|NO)
		    echo "   ERROR: Shorewall6 startup is disabled. To enable startup, set STARTUP_ENABLED=Yes in ${CONFDIR}/shorewall6.conf" >&2
		    exit 2
		    ;;
		Yes|yes|YES)
		    ;;
		*)
		    if [ -n "$STARTUP_ENABLED" ]; then
			echo "   ERROR: Invalid Value for STARTUP_ENABLED: $STARTUP_ENABLED" >&2
			exit 2
		    fi
		    ;;
	    esac
	fi

	case ${TC_ENABLED:=Internal} in
	    No|NO|no)
	        TC_ENABLED=
		;;
	esac

	[ -n "$LOGFORMAT" ] || LOGFORMAT='Shorewall6:%s.%s'

	[ -n "$LOGFORMAT" ] && LOGFORMAT="${LOGFORMAT%%%*}"

	if [ -n "$STARTUP_LOG" ]; then
	    if [ -n "$LOG_VERBOSITY" ]; then
		case $LOG_VERBOSITY in
		    -1)
			;;
		    0|1|2)
			;;
		    *)
		        echo "  ERROR: Invalid LOG_VERBOSITY ($LOG_VERBOSITY)" >&2
			exit 2;
			;;
		esac
	    else
		LOG_VERBOSITY=2;
	    fi
	else
	    LOG_VERBOSITY=-1;
	fi

    else
	STARTUP_LOG=
	LOG_VERBOSITY=-1
    fi   

    if [ -n "$SHOREWALL_SHELL" ]; then
	if [ ! -x "$SHOREWALL_SHELL" ]; then
	    echo "   WARNING: The program specified in SHOREWALL6_SHELL does not exist or is not executable; falling back to /bin/sh" >&2
	    SHOREWALL_SHELL=/bin/sh
	fi
    fi

    case $VERBOSITY in
	-1|0|1|2)
	    ;;
	*)
	    if [ -n "$VERBOSITY" ]; then
		echo "   ERROR: Invalid VERBOSITY setting ($VERBOSITY)" >&2
		exit 2
	    else
		VERBOSITY=2
	    fi
	    ;;
    esac

    [ -n "$g_use_verbosity" ] && VERBOSITY=$g_use_verbosity || VERBOSITY=$(($g_verbose_offset + $VERBOSITY))

    if [ $VERBOSITY -lt -1 ]; then
	VERBOSITY=-1
    elif [ $VERBOSITY -gt 2 ]; then
	VERBOSITY=2
    fi

    g_hostname=$(hostname 2> /dev/null)

    [ -n "$RSH_COMMAND" ] || RSH_COMMAND='ssh ${root}@${system} ${command}'
    [ -n "$RCP_COMMAND" ] || RCP_COMMAND='scp ${files} ${root}@${system}:${destination}'

    case $MANGLE_ENABLED in
	Yes|yes)
	    ;;
	No|no)
	    MANGLE_ENABLED=
	    ;;
	*)
	    if [ -n "$MANGLE_ENABLED" ]; then
		echo "   ERROR: Invalid MANGLE_ENABLED setting ($MANGLE_ENABLED)" >&2
		exit 2
	    fi
	    ;;
    esac

    case $AUTOMAKE in
	Yes|yes)
	    ;;
	No|no)
	    AUTOMAKE=
	    ;;
	*)
	    if [ -n "$AUTOMAKE" ]; then
		echo "   ERROR: Invalid AUTOMAKE setting ($AUTOMAKE)" >&2
		exit 1
	    fi
	    ;;
    esac

    case $LOAD_HELPERS_ONLY in
	Yes|yes)
	    ;;
	No|no)
	    LOAD_HELPERS_ONLY=
	    ;;
	*)
	    if [ -n "$LOAD_HELPERS_ONLY" ]; then
		echo "   ERROR: Invalid LOAD_HELPERS_ONLY setting ($LOAD_HELPERS_ONLY)" >&2
		exit 1
	    fi
	    ;;
    esac
}

#
# Issue an error message and die
#
startup_error() {
    echo "   ERROR: $@" >&2
    kill $$
    exit 1
}
    
#
# Run the appropriate compiler
#
compiler() {
    pc=/usr/$g_libexec/shorewall/compiler.pl

    local command
    command=$1

    shift
    
    if [ $(id -u) -ne 0 ]; then
	if [ -z "$SHOREWALL_DIR" -o "$SHOREWALL_DIR" = /etc/shorewall6 ]; then
	    startup_error "Ordinary users may not compile the /etc/shorewall6 configuration"
	fi
    fi
    #
    # We've now set SHOREWALL_DIR so recalculate CONFIG_PATH
    #
    ensure_config_path

    haveparams=

    case $COMMAND in
	*start|try|refresh)
	    ;;
	*)
	    STARTUP_LOG=
	    LOG_VERBOSITY=-1
	    ;;
    esac

    [ $command = exec ] || command=
    
    debugflags="-w"
    [ -n "$g_debug" ]   && debugflags='-wd'
    [ -n "$g_profile" ] && debugflags='-wd:DProf'

    # Perl compiler only takes the output file as a argument
	    
    [ "$1" = debug -o "$1" = trace ]  && shift;
    [ "$1" = nolock ] && shift;
    shift 

    options="--verbose=$VERBOSITY --family=6"
    [ -n "$STARTUP_LOG" ] && options="$options --log=$STARTUP_LOG"
    [ -n "$LOG_VERBOSITY" ] && options="$options --log_verbosity=$LOG_VERBOSITY";
    [ -n "$g_export" ] && options="$options --export"
    [ -n "$SHOREWALL_DIR" ] && options="$options --directory=$SHOREWALL_DIR"
    [ -n "$g_timestamp" ] && options="$options --timestamp"
    [ -n "$g_test" ] && options="$options --test"
    [ -n "$g_preview" ] && options="$options --preview"
    [ "$g_debugging" = trace ] && options="$options --debug"
    [ -n "$g_refreshchains" ] && options="$options --refresh=$g_refreshchains"
    [ -x $pc ] || startup_error "Shorewall6 requires the shorewall package which is not installed"

    if [ -n "$PERL" ]; then
	if [ ! -x "$PERL" ]; then
	    echo "   WARNING: The program specified in the PERL option does not exist or is not executable; falling back to /usr/bin/perl" >&2
	    PERL=/usr/bin/perl
	fi
    else
	PERL=/usr/bin/perl
    fi

    if [ $g_perllib != ${g_libexec}/shorewall ]; then
	PERL5LIB=$g_perllib
	export PERL5LIB
    fi
    
    $command $PERL $debugflags $pc $options $@
}    

#
# Start Command Executor
#
start_command() {
    local finished
    finished=0
    local restorefile

    do_it() {
	local rc
	rc=0

	if [ -n "$AUTOMAKE" ]; then
	    [ -n "$nolock" ] || mutex_on
	    run_it ${VARDIR}/firewall $g_debugging start
	    rc=$?
	    [ -n "$nolock" ] || mutex_off
	else
	    progress_message3 "Compiling..."

	    if compiler run $g_debugging $nolock compile ${VARDIR}/.start; then
		[ -n "$nolock" ] || mutex_on
		run_it ${VARDIR}/.start $g_debugging start
		rc=$?
		[ -n "$nolock" ] || mutex_off
	    else
		rc=$?
		logger -p kern.err "ERROR:Shorewall6 start failed"
	    fi
	fi

	exit $rc
    }

    if shorewall6_is_started; then
	error_message "Shorewall6 is already running"
	exit 0
    fi

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			d*)
			    g_debug=Yes
			    option=${option#d}
			    ;;
			f*)
			    g_fast=Yes
			    option=${option#f}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" -o -n "$g_fast" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    AUTOMAKE=
	    ;;
	*)
	    usage 1
	    ;;
    esac

    if [ -n "${g_fast}${AUTOMAKE}" ]; then
	if qt mywhich make; then
	    restorefile=$RESTOREFILE
	    if [ -z "$g_fast" ]; then
		#
		# Autofast -- use the last compiled script
		#
		RESTOREFILE=firewall
	    fi

	    export RESTOREFILE

	    if ! make -qf ${CONFDIR}/Makefile; then
		g_fast=
		AUTOMAKE=
	    fi

	    RESTOREFILE=$restorefile
	else
	    g_fast=
	    AUTOMAKE=
	fi

	if [ -n "$g_fast" ]; then
	    g_restorepath=${VARDIR}/$RESTOREFILE

	    if [ -x $g_restorepath ]; then
		echo Restoring Shorewall6...
		run_it $g_restorepath restore
		date > ${VARDIR}/restarted
		progress_message3 Shorewall6 restored from $g_restorepath
	    else
		do_it
	    fi
	else
	    do_it
	fi
    else
	do_it
    fi
}

#
# Compile Command Executor
#
compile_command() {
    local finished
    finished=0

    while [ $finished -eq 0 ]; do
	[ $# -eq 0 ] && break;
	option=$1
	case $option in
	    -*)
		shift
		option=${option#-}

		[ -z "$option" ] && usage 1

		while [ -n "$option" ]; do
		    case $option in
			e*)
			    g_export=Yes
			    option=${option#e}
			    ;;
			p*)
			    g_profile=Yes
			    option=${option#p}
			    ;;
			t*)
			    g_test=Yes
			    option=${option#t}
			    ;;			    
			d*)
			    g_debug=Yes;
			    option=${option#d}
			    ;;
			-)
			    finished=1
			    option=
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		;;
	    *)
		finished=1
		;;
	esac
    done

    file=

    case $# in
	0)
	    file=${VARDIR}/firewall
	    ;;
	1)
	    file=$1
	    [ -d $file ] && echo "   ERROR: $file is a directory" >&2 && exit 2;
	    ;;
	2)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    file=$2
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ "x$file" = x- ] || progress_message3 "Compiling..."

    compiler exec $g_debugging compile $file
}

#
# Check Command Executor
#
check_command() {
    local finished
    finished=0

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			e*)
			    g_export=Yes
			    option=${option#e}
			    ;;
			p*)
			    g_profile=Yes
			    option=${option#p}
			    ;;
			r*)
			    g_preview=Yes;
			    option=${option#r}
			    ;;
			d*)
			    g_debug=Yes;
			    option=${option#d}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    ;;
	*)
	    usage 1
	    ;;
    esac

    progress_message3 "Checking..."

    compiler exec $g_debugging $nolock check
}

#
# Restart Command Executor
#
restart_command() {
    local finished
    finished=0
    local rc
    rc=0
    local restorefile

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			d*)
			    g_debug=Yes
			    option=${option#d}
			    ;;
			f*)
			    g_fast=Yes
			    option=${option#f}
			    ;;
			n*)
			    g_noroutes=Yes
			    option=${option#n}
			    ;;
			p*)
			    [ -n "$(which conntrack)" ] || fatal_error "The '-p' option requires the conntrack utility which does not appear to be installed on this system"
			    g_purge=Yes
			    option=${option%p}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    [ -n "$g_fast" ] && fatal_error "Directory may not be specified with the -f option"
	    AUTOMAKE=
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    if [ -z "$g_fast" -a -n "$AUTOMAKE" ]; then
	if qt mywhich make; then
	    #
	    # RESTOREFILE is exported by get_config()
	    #
	    restorefile=$RESTOREFILE
	    RESTOREFILE=firewall
	    make -qf ${CONFDIR}/Makefile && g_fast=Yes
	    RESTOREFILE=$restorefile
	fi
    fi

    if [ -z "$g_fast" ]; then  
	progress_message3 "Compiling..."

	if compiler run $g_debugging $nolock compile ${VARDIR}/.restart; then
	    [ -n "$nolock" ] || mutex_on
	    run_it ${VARDIR}/.restart $g_debugging restart
	    rc=$?
	    [ -n "$nolock" ] || mutex_off
	else
	    rc=$?
	    logger -p kern.err "ERROR:Shorewall6 restart failed"
	fi
    else
	[ -x ${VARDIR}/firewall ] || fatal_error "No ${VARDIR}/firewall file found"
	[ -n "$nolock" ] || mutex_on
	run_it ${VARDIR}/firewall $g_debugging restart
	rc=$?
	[ -n "$nolock" ] || mutex_off
    fi

    return $rc
}

#
# Refresh Command Executor
#
refresh_command() {
    local finished
    finished=0

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    if [ $# -gt 0 ]; then
	g_refreshchains=$1
	shift

	while [ $# -gt 0 ]; do
	    g_refreshchains="$g_refreshchains,$1"
	    shift
	done
    else
	g_refreshchains=:refresh:
    fi

    shorewall6_is_started || fatal_error "Shorewall6 is not running"

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    progress_message3 "Compiling..."

    if compiler run $g_debugging $nolock compile ${VARDIR}/.refresh; then
	[ -n "$nolock" ] || mutex_on
	run_it ${VARDIR}/.refresh $g_debugging refresh
	rc=$?
	[ -n "$nolock" ] || mutex_off
    else
	rc=$?
    fi

    return $rc
}

#
# Safe-start/safe-restart Command Executor
#
safe_commands() {
    local finished
    finished=0

    # test is the shell supports timed read
    read -t 0 junk 2> /dev/null
    if [ $? -eq 2 -a ! -x /bin/bash ];then
	echo "Your shell does not support a feature required to execute this command".
	exit 2
    fi

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			n*)
			    g_noroutes=Yes
			    option=${option#n}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    ;;
	1)
	    [ -n "$SHOREWALL_DIR" ] && usage 2

	    if [ ! -d $1 ]; then
		if [ -e $1 ]; then
		    echo "$1 is not a directory" >&2 && exit 2
		else
		    echo "Directory $1 does not exist" >&2 && exit 2
		fi
	    fi

	    SHOREWALL_DIR=$(resolve_file $1)
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    if shorewall6_is_started; then
	running=Yes
    else
	running=
    fi

    if [ "$COMMAND" = "safe-start" -a  -n "$running" ]; then
	# the command is safe-start but the firewall is already running
	error_message "Shorewall6 is already started"
	exit 0
    fi

    if [ "$COMMAND" = "safe-start" -o -z "$running" ]; then
	# the command is safe-start or shorewall6 is not started yet
	command="start"
    else
	# the command is safe-restart and the firewall is already running
	command="restart"
    fi

    progress_message3 "Compiling..."

    if ! compiler run $g_debugging nolock compile ${VARDIR}/.$command; then
	status=$?
	exit $status
    fi

    case $command in
	start)
	    RESTOREFILE=NONE
	    progress_message3 "Starting..."
	    ;;
	restart)
	    RESTOREFILE=.safe
	    g_restorepath=${VARDIR}/.safe
	    save_config
	    progress_message3 "Restarting..."
	    ;;
    esac

    [ -n "$nolock" ] || mutex_on

    if run_it ${VARDIR}/.$command $command; then

	echo -n "Do you want to accept the new firewall configuration? [y/n] "

	if read_yesno_with_timeout; then
	    echo "New configuration has been accepted"
	else
	    if [ "$command" = "restart" ]; then
		run_it ${VARDIR}/.safe restore
	    else
		run_it ${VARDIR}/.$command clear
	    fi
	    
	    [ -n "$nolock" ] || mutex_off

	    echo "New configuration has been rejected and the old one restored"
	    exit 2
	fi

    fi

    [ -n "$nolock" ] || mutex_off
}

#
# 'try' Command Executor
#
try_command() {
    local finished
    finished=0
    local timeout
    timeout=

    handle_directory() {
	[ -n "$SHOREWALL_DIR" ] && usage 2

	if [ ! -d $1 ]; then
	    if [ -e $1 ]; then
		echo "$1 is not a directory" >&2 && exit 2
	    else
		echo "Directory $1 does not exist" >&2 && exit 2
	    fi
	fi
	
	SHOREWALL_DIR=$(resolve_file $1)
    }

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			n*)
			    g_noroutes=Yes
			    option=${option#n}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	0)
	    usage 1
	    ;;
	1)
	    handle_directory $1
	    ;;
	2)
	    handle_directory $1
	    timeout=$2
	    case $timeout in 
		*[!0-9]*)
                    echo "   ERROR: Invalid timeout ($timeout)" >&2;
		    exit 1
		    ;;
	    esac
	    ;;
	*)
	    usage 1
	    ;;
    esac

    [ -n "$STARTUP_ENABLED" ] || fatal_error "Startup is disabled"

    if shorewall6_is_started; then
	running=Yes
    else
	running=
    fi

    if [ -z "$running" ]; then
	# shorewall6 is not started yet
	command="start"
    else
	# the firewall is already running
	command="restart"
    fi

    progress_message3 "Compiling..."

    if ! compiler run $g_debugging $nolock compile ${VARDIR}/.$command; then
	status=$?
	exit $status
    fi

    case $command in
	start)
	    RESTOREFILE=NONE
	    progress_message3 "Starting..."
	    ;;
	restart)
	    RESTOREFILE=.try
	    g_restorepath=${VARDIR}/.try
	    save_config
	    progress_message3 "Restarting..."
	    ;;
    esac

    [ -n "$nolock" ] || mutex_on

    if run_it ${VARDIR}/.$command $command && [ -n "$timeout" ]; then
	sleep $timeout
	    
	if [ "$command" = "restart" ]; then
	    run_it ${VARDIR}/.try restore
	else
	    run_it ${VARDIR}/.$command clear
	fi	    
    fi

    [ -n "$nolock" ] || mutex_off

    return 0
}

rsh_command() {
    command="$*"

    eval $RSH_COMMAND
}

rcp_command() {
    files="$1"
    destination=$2
    
    eval $RCP_COMMAND
}

#
# [Re]load command executor
#
reload_command() # $* = original arguments less the command.
{
    local verbose
    verbose=$(make_verbose)
    local file
    file=
    local capabilities
    capabilities=
    local finished
    finished=0
    local saveit
    saveit=
    local result
    local directory
    local system
    local getcaps
    getcaps=
    local root
    root=root
    local compiler
    compiler=
    local libexec
    libexec=share

    litedir=/var/lib/shorewall6-lite

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			s*)
			    saveit=Yes
			    option=${option#s}
			    ;;
			c*)
			    getcaps=Yes
			    option=${option#c}
			    ;;
			r)
			    [ $# -gt 1 ] || fatal_error "Missing Root User name"
			    root=$2
			    option=
			    shift
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	1)
	    directory="."
	    system=$1
	    ;;
	2)
	    directory=$1
	    system=$2
	    ;;
	*)
	    usage 1
	    ;;
    esac

    temp=$(rsh_command /sbin/shorewall6-lite show config 2> /dev/null | grep ^LITEDIR | sed 's/LITEDIR is //')

    [ -n "$temp" ] && litedir=$temp

    temp=$(rsh_command /sbin/shorewall6-lite show config 2> /dev/null | grep ^LIBEXEC | sed 's/LIBEXEC is //')

    [ -n "$temp" ] && libexec=$temp

    if [ -z "$getcaps" ]; then
	SHOREWALL_DIR=$(resolve_file $directory)
	ensure_config_path
	capabilities=$(find_file capabilities)
	[ -f $capabilities ] || getcaps=Yes
    fi

    if [ -n "$getcaps" ]; then
	if [ -f $directory/shorewall6.conf ]; then
	    . $directory/shorewall6.conf
	    ensure_config_path
	fi

	progress_message "Getting Capabilities on system $system..."
	if ! rsh_command "MODULESDIR=$MODULESDIR MODULE_SUFFIX=\"$MODULE_SUFFIX\" IP6TABLES=$IP6TABLES /usr/$libexec/shorewall6-lite/shorecap" > $directory/capabilities; then
	    fatal_error "ERROR: Capturing capabilities on system $system failed"
	fi
    fi

    file=$(resolve_file $directory/firewall)

    [ -n "$g_timestamp" ] && timestamp='-t' || timestamp=

    if shorewall6 $g_debugging $verbose $timestamp compile -e $compiler $directory $directory/firewall && \
	progress_message3 "Copying $file and ${file}.conf to ${system}:${litedir}..." && \
	rcp_command "$directory/firewall $directory/firewall.conf" ${litedir}
    then
	save=$(find_file save);

	[ -f $save ] && progress_message3 "Copying $save to ${system}:/etc/shorewall6-lite/" && rcp_command $save /etc/shorewall6-lite/

	progress_message3 "Copy complete"
	if [ $COMMAND = reload ]; then
	    rsh_command "/sbin/shorewall6-lite $g_debugging $verbose $timestamp restart" && \
	    progress_message3 "System $system reloaded" || saveit=
	else
	    rsh_command "/sbin/shorewall6-lite $g_debugging $verbose $timestamp start" && \
	    progress_message3 "System $system loaded" || saveit=
	fi

	if [ -n "$saveit" ]; then
	    rsh_command "/sbin/shorewall6-lite $g_debugging $verbose $timestamp save" && \
	    progress_message3 "Configuration on system $system saved"
	fi
    fi
}

#
# Export command executor
#
export_command() # $* = original arguments less the command.
{
    local verbose
    verbose=$(make_verbose) 
    local file
    file= 
    local finished
    finished=0 
    local directory 
    local target
    local compiler
    compiler=

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			*)
			    fatal_error "Unrecognized option \"$option\""
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    case $# in
	1)
	    directory="."
	    target=$1
	    ;;
	2)
	    directory=$1
	    target=$2
	    ;;
	*)
	    fatal_error "ERROR: Invalid command syntax (\"man shorewall6\" for help)"
	    ;;
    esac

    case $target in
	*:*)
	    ;;
	*)
	    target=$target:
	    ;;
    esac

    file=$(resolve_file $directory/firewall)

    if shorewall6 $g_debugging $verbose compile -e $compiler $directory $directory/firewall && \
	echo "Copying $file and ${file}.conf to ${target#*@}..." && \
	scp $directory/firewall $directory/firewall.conf $target
    then
	save=$(find_file save);

	[ -f $save ] && progress_message3 "Copying $save to ${target#*}..." && rcp_command $save $target

	progress_message3 "Copy complete"
    fi
}

#
# Give Usage Information
#
usage() # $1 = exit status
{
    echo "Usage: $(basename $0) [debug|trace] [nolock] [ -q ] [ -v[-1|{0-2}] ] [ -t ] <command>"
    echo "where <command> is one of:"
    echo "   add <interface>[:<host-list>] ... <zone>"
    echo "   allow <address> ..."
    echo "   check [ -e ] [ -r ] [ <directory> ]"
    echo "   clear"
    echo "   compile [ -e ] [ -d ] [ <directory name> ] [ <path name> ]"
    echo "   delete <interface>[:<host-list>] ... <zone>"
    echo "   drop <address> ..."
    echo "   dump [ -x ]"
    echo "   export [ <directory1> ] [<user>@]<system>[:<directory2>]"
    echo "   forget [ <file name> ]"
    echo "   help"
    echo "   iptrace <ip6tables match expression>"
    echo "   load [ -s ] [ -c ] [ -r <root user> ] [ <directory> ] <system>"
    echo "   logdrop <address> ..."
    echo "   logreject <address> ..."
    echo "   logwatch [<refresh interval>]"
    echo "   noiptrace <ip6tables match expression>"
    echo "   refresh [ <chain>... ]"
    echo "   reject <address> ..."
    echo "   reload [ -s ] [ -c ] [ -r <root user> ] [ <directory> ] <system>"
    echo "   reset [ <chain> ... ]"
    echo "   restart [ -n ] [ -f ] [ <directory> ]"
    echo "   restore [ -n ] [ <file name> ]"
    echo "   save [ <file name> ]"
    echo "   show [ -x ] [ -m ] [-f] [ -t {filter|mangle} ] [ {chain [<chain> [ <chain> ... ]|actions|capabilities|classifiers|config|connections|filters|ip|log [<regex>]|macros|mangle|nat|policies|raw|routing|tc|vardir|zones} ]"
    echo "   start [ -f ] [ -n ] [ <directory> ]"
    echo "   stop"
    echo "   status"
    echo "   try <directory> [ <timeout> ]"
    echo "   version [ -a ]"
    echo "   safe-start [ <directory> ]"
    echo "   safe-restart [ <directory> ]"
    echo
    exit $1
}

version_command() {
    local finished
    finished=0
    local all
    all=

    while [ $finished -eq 0 -a $# -gt 0 ]; do
	option=$1
	case $option in
	    -*)
		option=${option#-}

		while [ -n "$option" ]; do
		    case $option in
			-)
			    finished=1
			    option=
			    ;;
			a*)
			    all=Yes
			    option=${option#a}
			    ;;
			*)
			    usage 1
			    ;;
		    esac
		done
		shift
		;;
	    *)
		finished=1
		;;
	esac
    done

    [ $# -gt 0 ] && usage 1

    echo $SHOREWALL_VERSION

    if [ -n "$all" ]; then
	for product in shorewall shorewall-lite shorewall6-lite shorewall-init; do
	    if [ -f /usr/share/$product/version ]; then
		echo "$product: $(cat /usr/share/$product/version)"
	    fi
	done
    fi
}

#
# Execution begins here
#
g_debugging=

if [ $# -gt 0 ] && [ "x$1" = "xdebug" -o "x$1" = "xtrace" ]; then
    g_debugging=$1
    shift
fi

nolock=

if [ $# -gt 0 ] && [ "$1" = "nolock" ]; then
    nolock=nolock
    shift
fi

SHOREWALL_DIR=
g_ipt_options="-nv"
g_fast=
g_verbose_offset=0
g_use_verbosity=
g_debug=
g_export=
g_refreshchains=:none:

g_noroutes=
g_purge=
g_timestamp=

#
# Make sure that these variables are cleared
#
VERBOSE=
VERBOSITY=

finished=0

while [ $finished -eq 0 ]; do
    [ $# -eq 0 ] && usage 1
    option=$1
    case $option in
	-)
	    finished=1
	    ;;
	-*)
	    option=${option#-}

	    while [ -n "$option" ]; do
		case $option in
		    c)
			[ $# -eq 1 ] && usage 1

			if [ ! -d $2 ]; then
			    if [ -e $2 ]; then
				echo "$2 is not a directory" >&2 && exit 2
			    else
				echo "Directory $2 does not exist" >&2 && exit 2
			    fi
			fi

			SHOREWALL_DIR=$(resolve_file $2)
			option=
			shift
			;;
		    e*)
			g_export=Yes
			option=${option#e}
			;;
		    x*)
			g_ipt_options="-xnv"
			option=${option#x}
			;;
		    q*)
			g_verbose_offset=$(($g_verbose_offset - 1 ))
			option=${option#q}
			;;
		    f*)
			g_fast=Yes
			option=${option#f}
			;;
		    v*)
			option=${option#v}
			case $option in 
			    -1*)
				g_use_verbosity=-1
				option=${option#-1}
				;;
			    0*)
				g_use_verbosity=0
				option=${option#0}
				;;
			    1*)
				g_use_verbosity=1
				option=${option#1}
				;;
			    2*)
				g_use_verbosity=2
				option=${option#2}
				;;
			    *)
				g_verbose_offset=$(($g_verbose_offset + 1 ))
				g_use_verbosity=
				;;
			esac
			;;
		    n*)
			g_noroutes=Yes
			option=${option#n}
			;;
		    t*)
			g_timestamp=Yes
			option=${option#t}
			;;
		    -)
			finished=1
			option=
			;;
		    *)
			usage 1
			;;
		esac
	    done
	    shift
	    ;;
	*)
	    finished=1
            ;;
    esac
done

if [ $# -eq 0 ]; then
    usage 1
fi

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin
MUTEX_TIMEOUT=

SHAREDIR=/usr/share/shorewall6
CONFDIR=/etc/shorewall6
g_product="Shorewall6"
g_recovering=
g_libexec=share
g_perllib=share/shorewall

[ -f ${CONFDIR}/vardir ] && . ${CONFDIR}/vardir

[ -n "${VARDIR:=/var/lib/shorewall6}" ]

if [ ! -f ${VARDIR}/firewall ]; then
    [ -f ${VARDIR}/.restore ] && cp -f ${VARDIR}/.restore ${VARDIR}/firewall 
fi

g_firewall=${VARDIR}/firewall

for library in base cli; do
    . ${SHAREDIR}/lib.$library
done

version_file=$SHAREDIR/version
if [ -f $version_file ]; then
    SHOREWALL_VERSION=$(cat $version_file)
else
    echo "   ERROR: Shorewall6 is not properly installed" >&2
    echo "	 The file $version_file does not exist"  >&2
    exit 1
fi

banner="Shorewall6-$SHOREWALL_VERSION Status at $g_hostname -"

case $(echo -e) in
    -e*)
	g_ring_bell="echo \a"
	g_echo_e="echo"
	;;
    *)
	g_ring_bell="echo -e \a"
	g_echo_e="echo -e"
	;;
esac

case $(echo -n "Testing") in
    -n*)
	g_echo_n=
	;;
    *)
	g_echo_n=-n
	;;
esac

COMMAND=$1

case "$COMMAND" in
    start)
	get_config Yes Yes
	shift
	start_command $@
	;;
    stop|clear)
	[ $# -ne 1 ] && usage 1
	get_config
	[ -x $g_firewall ] || fatal_error "Shorewall6 has never been started"
	[ -n "$nolock" ] || mutex_on
	run_it $g_firewall $g_debugging $COMMAND
	[ -n "$nolock" ] || mutex_off
	;;
    reset)
	get_config
	shift
	[ -n "$nolock" ] || mutex_on
	[ -x $g_firewall ] || fatal_error "Shorewall6 has never been started"
	run_it $g_firewall $g_debugging reset $@
	[ -n "$nolock" ] || mutex_off
	;;
    compile)
	get_config Yes
	shift
	compile_command $@
	;;
    restart)
	get_config Yes Yes
	shift
	restart_command $@
	;;
    refresh)
	get_config Yes Yes
	shift
	refresh_command $@
	;;
    check)
	get_config Yes
	shift
	check_command $@
	;;
    show|list)
	get_config Yes No Yes
    	shift
    	show_command $@
	;;
    load|reload)
	get_config Yes
	shift
	reload_command $@
	;;
    export)
	get_config Yes
	shift
	export_command $@
	;;
    status)
	[ $# -eq 1 ] || usage 1
	[ "$(id -u)" != 0 ] && fatal_error "ERROR: The status command may only be run by root"
	get_config
	echo "Shorewall6-$SHOREWALL_VERSION Status at $g_hostname - $(date)"
	echo
	if shorewall6_is_started ; then
	    echo "Shorewall6 is running"
	    status=0
	else
	    echo "Shorewall6 is stopped"
	    status=4
	fi

	if [ -f ${VARDIR}/state ]; then
	    state="$(cat ${VARDIR}/state)"
	    case $state in
		Stopped*|Closed*|Clear*)
		    status=3
		    ;;
	    esac
	else
	    state=Unknown
	fi
	echo "State:$state"
	echo
	exit $status
	;;
    dump)
	get_config Yes No Yes
    	shift
    	dump_command $@
	;;
    version)
	shift
	version_command $@
	;;
    try)
	get_config Yes
	shift
	try_command $@
	;;
    logwatch)
	get_config Yes Yes Yes
	banner="Shorewall6-$SHOREWALL_VERSION Logwatch at $g_hostname -"
	logwatch_command $@
	;;
    drop)
	get_config
	[ -n "$g_debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall6_is_started ; then
	    [ -n "$nolock" ] || mutex_on
	    block DROP Dropped $*
	    [ -n "$nolock" ] || mutex_off
	else
	    fatal_error "Shorewall6 is not started"
	fi
	;;
    logdrop)
	get_config
	[ -n "$g_debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall6_is_started ; then
	    [ -n "$nolock" ] || mutex_on
	    block logdrop Dropped $*
	    [ -n "$nolock" ] || mutex_off
	else
	    fatal_error "Shorewall6 is not started"
	fi
	;;
    reject|logreject)
	get_config
	[ -n "$g_debugging" ] && set -x
	[ $# -eq 1 ] && usage 1
	if shorewall6_is_started ; then
	    [ -n "$nolock" ] || mutex_on
	    block $COMMAND Rejected $*
	    [ -n "$nolock" ] || mutex_off
	else
	    fatal_error "Shorewall6 is not started"
	fi
	;;
    allow)
	get_config
	allow_command $@
	;;
    save)
	get_config
	[ -n "$g_debugging" ] && set -x

	case $# in
	1)
	    ;;
	2)
	    RESTOREFILE="$2"
	    validate_restorefile '<restore file>'
	    ;;
	*)
	    usage 1
	    ;;
	esac

	g_restorepath=${VARDIR}/$RESTOREFILE

	[ -n "$nolock" ] || mutex_on

	save_config

	result=$?

	[ -n "$nolock" ] || mutex_off

	exit $result
	;;
    forget)
	get_config
	case $# in
	1)
	    ;;
	2)
	    RESTOREFILE="$2"
	    validate_restorefile '<restore file>'
	    ;;
	*)
	    usage 1
	    ;;
	esac

	g_restorepath=${VARDIR}/$RESTOREFILE

	if [ -x $g_restorepath ]; then

	    if [ -x ${g_restorepath}-ipsets ]; then
		rm -f ${g_restorepath}-ipsets
		echo "    ${g_restorepath}-ipsets removed"
	    fi

	    rm -f $g_restorepath
	    rm -f ${g_restorepath}-iptables
	    echo "    $g_restorepath removed"
	elif [ -f $g_restorepath ]; then
	    echo "   $g_restorepath exists and is not a saved Shorewall6 configuration"
	fi
	rm -f ${VARDIR}/save
	;;
    restore)
	get_config
	shift
	restore_command $@
        ;;
    call)
	get_config
	[ -n "$g_debugging" ] && set -x
	#
	# Undocumented way to call functions in ${SHAREDIR}/functions directly
	#
	shift
	$@
	;;
    help)
	shift
	usage
	;;
    safe-restart|safe-start)
	get_config Yes
	shift
	safe_commands $@
	;;
    iptrace)
	get_config
	shift
	if shorewall_is_started ; then
	    $IP6TABLES -t raw -A PREROUTING $@ -j TRACE
	    $IP6TABLES -t raw -A OUTPUT $@ -j TRACE
	else
	    fatal_error "Shorewall6 is not started"
	fi
	;;	
     noiptrace)
	get_config
	shift
	if shorewall_is_started ; then
	    $IP6TABLES -t raw -D PREROUTING $@ -j TRACE
	    $IP6TABLES -t raw -D OUTPUT $@ -j TRACE
	else
	    fatal_error "Shorewall6 is not started"
	fi
	;;	    *)
	usage 1
	;;

esac
